```
假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？
遍历10万条数据，以URL为key，访问次数为value，存入散列表<URL><访问次数>, 同时记录下访问次数的最大值K，时间复杂度O(N).
如果K不是很大，可以使用桶排序，时间复杂度为O(N).
如果K很大（比如接近10万），就使用快速排序，复杂度为O(NlogN)
```
```
有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？
以第一个数组构建散列表<key><value出现次数>。再遍历第二个字符串，以字符串为Key在散列表中查找，如果value>0,说明存在相同的字符串。时间复杂度O(N).
```
```
为什么散列表和链表经常一块使用？
散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。
也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。

因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。
为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。
```
```
假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。
假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：
根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；
查找积分在某个区间的猎头 ID 列表；
查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。
A:
以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。
1）ID 在散列表中所以可以 O(1) 查找到这个猎头；
2）积分以跳表存储，跳表支持区间查询；
3）这点根据目前学习的知识暂时无法实现，老师文中也提到了。
```
```
散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。
而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？
A:
我认为有下面几个原因：
第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。
第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。
第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。
加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。
平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。
最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。
```
