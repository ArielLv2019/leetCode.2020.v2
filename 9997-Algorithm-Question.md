```
假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？
遍历10万条数据，以URL为key，访问次数为value，存入散列表<URL><访问次数>, 同时记录下访问次数的最大值K，时间复杂度O(N).
如果K不是很大，可以使用桶排序，时间复杂度为O(N).
如果K很大（比如接近10万），就使用快速排序，复杂度为O(NlogN)
```
```
有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？
以第一个数组构建散列表<key><value出现次数>。再遍历第二个字符串，以字符串为Key在散列表中查找，如果value>0,说明存在相同的字符串。时间复杂度O(N).
```
```
为什么散列表和链表经常一块使用？
散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。
也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。

因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。
为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。
```
```
假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。
假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：
根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；
查找积分在某个区间的猎头 ID 列表；
查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。
A:
以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。
1）ID 在散列表中所以可以 O(1) 查找到这个猎头；
2）积分以跳表存储，跳表支持区间查询；
3）这点根据目前学习的知识暂时无法实现，老师文中也提到了。
```
